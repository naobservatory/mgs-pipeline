<!--

To rebuild:
1. Run mgs pipeline
2. dashboard/prepare-dashboard-data.sh makes data.js

-->

<title>Viral Counts Explorer</title>
<h1>Viral Counts Explorer</h1>

<div id=loading>
loading...
</div>

<p>

This tool displays a summary of the output of the <a
href="https://www.naobservatory.org/">NAO</a> metagenomic sequencing
pipeline (<a
href="https://github.com/naobservatory/mgs-pipeline">code</a>).

<p>

<div class=search_box>
Limit Papers:

<p>

<table>
  <tr><td>Nucleic Acid<td><input id=na_search type=text size=34></input>
  <tr><td>Min reads<td><input size=5 value=1e1 id=min_reads_search
          type=text></input>
  <!-- todo: once we have more categorizations on the papers (enrichment?
       filtration? sample type?) these can go here -->
</table>
</div>

  <p>


<table id=table_papers cellpadding=5 rules=rows>
  <tr><th><th>Name<th>Reads<th>Acid<th>Samples<th>Location<th>Date<th>Bioprojects
</table>

<p>

<div class=search_box>

Search organisms: <input id=taxonomic_search type=text size=34></input>

  <p>
  <br>

Limit Samples:
<p>
<table>
  <tr><td>Country<td><input id=country_search type=text size=34></input>
  <tr><td>City<td><input id=city_search type=text size=34></input>
  <tr><td>Date<td>
  <input size=15 id=date_begin_search type=text></input> &ndash;
     <input size=15 id=date_end_search type=text></input>
</table>
</div>

<p>
Rows are taxonomic nodes, columns are samples (or collections of samples), cells
are relative abundance of human viruses that match that taxonomic node.
<p>


<table id=tbl></table>
<style>
  #tbl td {
    word-wrap: break-word;
    max-width: 15em;
    min-width: 5em;
    padding: 0.5em;
  }
  #tbl tr {
    border-top: 1px solid black;
  }
  #tbl .header {
    border-top: none;
  }
  #tbl .header td {
    padding: 0.1em;
    padding-right: 0.5em;
  }
  tr {
    vertical-align: top;
  }
  th {
    text-align: left;
    padding-right: 0.5em;
  }
  .details {
    background-color: #eee;
  }
  #tbl {
    border-collapse: collapse;
  }
  .search_box {
    border: 1px solid black;
    border-radius: 0.5em;
    padding: 1em;
    display: inline-block;
  }
  .error {
    border: 1px solid red;
    color: red;
  }
  #loading {
    padding: 2em;
  }
</style>

<script src="data.js"></script>
<script>

// imports:
//   virus_sample_counts: taxid -> sample -> count
//   sample_metadata: sample -> {country, date, location, reads}
//   bioprojects: project -> [samples]
//   papers: paper -> {link, na_type, [projects]}
//   names: taxid -> name
//   tree: taxid with children

window.onerror = function () {
  document.body.style.border = "5px solid red";
  document.body.style.borderRadius = "1em";
};

const paper_names = [];
for (const paper in papers) {
  paper_names.push(paper);
}
paper_names.sort();

for (const sample in sample_metadata) {
  if (sample_metadata[sample].date == "Summer 2013") {
    // Make it sort properly.
    sample_metadata[sample].date = "2013-Summer";
  }
}

const paper_countries = {};
const paper_locations = {};
const paper_fine_locations = {};
const paper_dates = {};

for (const paper_name of paper_names) {
  paper_countries[paper_name] = new Set();
  paper_locations[paper_name] = new Set();
  paper_fine_locations[paper_name] = new Set();
  paper_dates[paper_name] = new Set();

  for (const bioproject of papers[paper_name].projects) {
    if (!bioprojects[bioproject]) continue;
    for (const sample of bioprojects[bioproject]) {
      paper_countries[paper_name].add(sample_metadata[sample].country);
      paper_locations[paper_name].add(sample_metadata[sample].location);
      if (sample_metadata[sample].fine_location) {
        paper_fine_locations[paper_name].add(
          sample_metadata[sample].fine_location);
      }
      if (sample_metadata[sample].date) {
        paper_dates[paper_name].add(sample_metadata[sample].date);
      }
    }
  }
}

function paper_expansion_options(paper_name) {
  const forced_minimum_level_index = expansion_levels.indexOf(
    forced_minimum_level());
  const options = [];
  if (expansion_levels.indexOf("collapsed") >= forced_minimum_level_index) {
    options.push("collapsed");
  }
  if ((paper_countries[paper_name].size > 1 &&
       expansion_levels.indexOf("country") > forced_minimum_level_index) ||
      (paper_countries[paper_name].size > 0 &&
       expansion_levels.indexOf("country") == forced_minimum_level_index)) {
    options.push("country");
  }
  if ((paper_locations[paper_name].size > paper_countries[paper_name].size &&
       expansion_levels.indexOf("location") > forced_minimum_level_index) ||
      (paper_locations[paper_name].size > 0 &&
       expansion_levels.indexOf("location") == forced_minimum_level_index)) {
    options.push("location");
  }
  if ((paper_fine_locations[paper_name].size > 1 &&
       expansion_levels.indexOf("fine") > forced_minimum_level_index) ||
      (paper_fine_locations[paper_name].size > 0 &&
       expansion_levels.indexOf("fine") ==  forced_minimum_level_index)) {
    options.push("fine");
  }
  if (expansion_levels.indexOf("sample") > forced_minimum_level_index) {
    options.push("sample");
  }
  return options;
}

function summarize_location(paper_name) {
  if (paper_countries[paper_name].size == 1 &&
      paper_locations[paper_name].size == 1) {
    const [location] = paper_locations[paper_name];
    return location;
  }
  if (paper_countries[paper_name].size == 1) {
    const [country] = paper_countries[paper_name];
    return country;
  }
  return "Multiple";
}

function summarize_date(paper_name) {
  if (paper_name == "Petersen 2015" &&
      [...paper_dates[paper_name]][0] == "2013-Summer") {
    // We don't know which sample is which date, but we do know the
    // overall range.
    return "2013-06 to 2013-08";
  }

  if (paper_dates[paper_name].size == 1) {
    const [date] = paper_dates[paper_name];
    return date;
  }

  const sorted_dates = [...paper_dates[paper_name]].sort();

  let first = sorted_dates[0];
  let last = sorted_dates[sorted_dates.length - 1];

  // If one of our bounds is year-only, truncate the other to the year
  // as well.
  if (/^20\d\d$/.test(first) && /^20\d\d.*/.test(last)) {
    last = last.substring(0, 4);
  } else if (/^20\d\d$/.test(last) && /^20\d\d.*/.test(first)) {
    first = first.substring(0, 4);
  }

  if (first.substring(0, 4) != last.substring(0, 4)) {
    // When dates span years, just use the years.
    first = first.substring(0, 4);
    last = last.substring(0, 4);
  } else if (first.substring(0, 7) != last.substring(0, 7)) {
    // When same-year dates span months, just use the months.
    first = first.substring(0, 7);
    last = last.substring(0, 7);
  }

  return first + " to " + last;
}

function sample_description(target_sample, paper_name) {
  const name_bits = [];
  name_bits.push(sample_metadata[target_sample].country || "Unknown");
  if (sample_metadata[target_sample].location) {
    name_bits.push(sample_metadata[target_sample].location);
  }
  if (sample_metadata[target_sample].fine_location) {
    name_bits.push(sample_metadata[target_sample].fine_location);
  }
  if (sample_metadata[target_sample].date) {
    name_bits.push(sample_metadata[target_sample].date);
  }
  return name_bits;
}


const paper_trs = {}; // paper -> row in papers table

function is_sci_num(s) {
  return /^\d+e\d+$/.test(s);
}

function check_input_errors() {
  if (min_reads_search.value && !is_sci_num(min_reads_search.value)) {
    min_reads_search.classList.add("error");
  } else {
    min_reads_search.classList.remove("error");
  }
}

function update_paper_visibility() {
  for (const paper_tr of Object.values(paper_trs)) {
    paper_tr.hidden = false;
    if (!paper_tr.na_type.toLowerCase().includes(na_search.value.toLowerCase())) {
      paper_tr.hidden = true;
    }
    if (min_reads_search.value &&
        is_sci_num(min_reads_search.value) &&
        paper_tr.total_reads < parseFloat(min_reads_search.value)) {
      paper_tr.hidden = true;
    }
  }
}

for (const paper_name of paper_names) {
  const tr = e("tr");

  const td_include = e("td");
  const input_include = e("input");
  input_include.type = "checkbox";
  input_include.checked = true;
  input_include.onchange = redisplay;
  td_include.appendChild(input_include);
  tr.appendChild(td_include);

  const td_name = e("td");
  const a_name = e("a", paper_name);
  a_name.href = papers[paper_name].link;
  a_name.target = "_blank";
  td_name.appendChild(a_name);
  tr.appendChild(td_name);

  let total_reads = 0;
  let total_samples = 0;
  for (const bioproject of papers[paper_name].projects) {
    if (!bioprojects[bioproject]) continue;
    for (const sample of bioprojects[bioproject]) {
      total_reads += sample_metadata[sample].reads;
      total_samples += 1;
    }
  }

  if (total_reads == 0) {
    continue;
  }

  tr.checkbox = input_include;
  tr.total_reads = total_reads;
  tr.na_type = papers[paper_name].na_type;
  tr.hidden = false;

  tr.appendChild(e("td", human_readable(total_reads) + " reads"));
  tr.appendChild(e("td", papers[paper_name].na_type));
  tr.appendChild(e("td", total_samples));
  tr.appendChild(e("td", summarize_location(paper_name)));
  tr.appendChild(e("td", summarize_date(paper_name)));

  const td_bioprojects = e("td");
  for (const bioproject of papers[paper_name].projects) {
    const a_bioproject = e("a", bioproject);
    a_bioproject.href = "https://www.ebi.ac.uk/ena/browser/view/" + bioproject;
    a_bioproject.target = "_blank";
    td_bioprojects.appendChild(a_bioproject);
    td_bioprojects.appendChild(e("br"));
  }
  tr.appendChild(td_bioprojects);

  table_papers.appendChild(tr);
  paper_trs[paper_name] = tr;
}

function e(tag, innerText) {
  const el = document.createElement(tag);
  if (innerText) {
    el.innerText = innerText;
  }
  return el;
}

function clean_date(raw_date, is_begin) {
  if (!raw_date) return null;

  if (raw_date == "2013-Summer") {
    // Special casing Petersen 2015.
    if (is_begin) {
      return "2013-06";
    }
    return "2013-08";
  }

  if (/^20\d\d$/.test(raw_date)) {
    if (is_begin) {
      return raw_date += "-01-01";
    }
    return raw_date += "-12-31";
  }
  if (/^20\d\d-\d\d$/.test(raw_date)) {
    if (is_begin) {
      return raw_date += "-01";
    }
      return raw_date + "-31";
  }
  if (/^20\d\d-\d\d-\d\d$/.test(raw_date)) {
    return raw_date;
  }
  return null;
}

function human_readable(n) {
  function s(v, suffix) {
    let vStr = v.toPrecision(3);
    if (vStr.includes(".")) {
      vStr = v.toPrecision(2);
    }
    return vStr + suffix;
  }
  if (n < 1000) return n;
  n /= 1000;
  if (n < 1000) return s(n,'k');
  n /= 1000;
  if (n < 1000) return s(n,'M');
  n /= 1000;
  if (n < 1000) return s(n, 'B');
  n /= 1000;
  if (n < 1000) return s(n, 'T');
  n /= 1000;
  return s(n, 'Q');
}

function cell_value(count, total, is_leaf) {
  if (count == 0) {
    return "< " + sci_num(1/total);
  }
  const val = count / total;
  if (is_leaf) {
    return sci_num(val) + " (" + count + ")";
  }
  return sci_num(val);
}

function sci_num(x) {
  return x.toExponential(1);
}

function sci_color(x) {
  if (x > 1e-5) {
    return '#f9f';
  } else if (x > 1e-6) {
    return '#faf';
  } else if (x > 1e-7) {
    return '#fbf';
  } else if (x > 1e-8) {
    return '#fcf';
  } else if (x > 1e-9) {
    return '#fdf';
  } else if (x > 1e-10) {
    return '#fef';
  }
  return '#fff';
}

const rightTriangle = "&rarr;";
const downTriangle = "&darr;";

const manually_expanded_taxids = new Set();

function manually_expand(taxid) {
  manually_expanded_taxids.add(taxid);
  redisplay();
}

function refresh_taxonomic_expansion() {
  manually_expanded_taxids.clear();
  redisplay();
}

function expand_paper(e) {
  const paper_name = e.target.paper_name;
  const options = paper_expansion_options(paper_name);
  const current_level = paper_expansion(paper_name);
  paper_expansions[paper_name] = options[options.indexOf(current_level) + 1];
  redisplay();
}

function collapse_paper(e) {
  const paper_name = e.target.paper_name;
  const options = paper_expansion_options(e.target.paper_name);

  const current_option_index = options.indexOf(
    paper_expansions[paper_name]);
  if (current_option_index == 0) {
    delete paper_expansions[paper_name];
  } else {
    paper_expansions[paper_name] = options[current_option_index - 1];
  }
  redisplay();
}

const expansion_levels = ["collapsed", "country", "location", "fine", "sample"];

// paper_name -> expansion level
const paper_expansions = {}
for (paper_name of paper_names) {
  paper_expansions[paper_name] = "collapsed";
}

function forced_minimum_level() {
  if (date_begin_search.value || date_end_search.value) return "sample";
  if (city_search.value) return "location";
  if (country_search.value) return "country";
  return "collapsed";
}

function paper_expansion(paper_name) {
  const options = paper_expansion_options(paper_name);
  if (!options.length) {
    return "sample";
  }
  let current_level = paper_expansions[paper_name];
  if (options.indexOf(current_level) == -1) {
    current_level = options[0];
  }

  const min_level = forced_minimum_level();
  if (min_level &&
      expansion_levels.indexOf(min_level) >
      expansion_levels.indexOf(current_level)){
    return min_level;
  }
  return current_level;
}

// -> [samples, ...]
function categorize_samples_at_current_expansion(paper_name) {
  const samples_list = [];
  if (paper_expansion(paper_name) == "collapsed") {
    const samples = [];
    for (const bioproject of papers[paper_name].projects) {
      if (!bioprojects[bioproject]) continue;
      for (const sample of bioprojects[bioproject]) {
        samples.push(sample)
      }
    }
    sort_samples(samples);
    samples_list.push(samples);
  } else if (paper_expansion(paper_name) == "country") {
    for (const country of [...paper_countries[paper_name]].sort()) {
      if (country_search.value &&
          (!country || !country.toLowerCase().includes(
            country_search.value.toLowerCase()))) {
        continue;
      }
      const samples = [];
      for (const bioproject of papers[paper_name].projects) {
        if (!bioprojects[bioproject]) continue;
        for (const sample of bioprojects[bioproject]) {
          if (sample_metadata[sample].country == country) {
            samples.push(sample);
          }
        }
      }
      sort_samples(samples);
      samples_list.push(samples);
    }
  } else if (paper_expansion(paper_name) == "location") {
    for (const country of [...paper_countries[paper_name]].sort()) {
      if (country_search.value &&
          (!country || !country.toLowerCase().includes(
            country_search.value.toLowerCase()))) {
        continue;
      }
      for (const location of [...paper_locations[paper_name]].sort()) {
        if (city_search.value &&
            (!location || !location.toLowerCase().includes(
              city_search.value.toLowerCase()))) {
          continue;
        }
        const samples = [];
        for (const bioproject of papers[paper_name].projects) {
          if (!bioprojects[bioproject]) continue;
          for (const sample of bioprojects[bioproject]) {
            if (sample_metadata[sample].country == country &&
                sample_metadata[sample].location == location) {
              samples.push(sample);
            }
          }
        }
        if (samples.length) {
          sort_samples(samples);
          samples_list.push(samples);
        }
      }
    }
  } else if (paper_expansion(paper_name) == "fine") {
    for (const country of [...paper_countries[paper_name]].sort()) {
      if (country_search.value &&
          (!country || !country.toLowerCase().includes(
            country_search.value.toLowerCase()))) {
        continue;
      }
      for (const location of [...paper_locations[paper_name]].sort()) {
        if (city_search.value &&
            (!location || !location.toLowerCase().includes(
              city_search.value.toLowerCase()))) {
          continue;
        }
        for (const fine_location of
             [...paper_fine_locations[paper_name]].sort()) {
          const samples = [];
          for (const bioproject of papers[paper_name].projects) {
            if (!bioprojects[bioproject]) continue;
            for (const sample of bioprojects[bioproject]) {
              if (sample_metadata[sample].country == country &&
                  sample_metadata[sample].location == location &&
                  sample_metadata[sample].fine_location == fine_location) {
                samples.push(sample);
              }
            }
          }
          if (samples.length) {
            sort_samples(samples);
            samples_list.push(samples);
          }
        }
      }
    }
  } else if (paper_expansion(paper_name) == "sample") {
    let target_date_begin = clean_date(date_begin_search.value,
                                       /*is_begin=*/true);
    let target_date_end = clean_date(date_end_search.value,
                                     /*is_begin=*/false);

    for (const bioproject of papers[paper_name].projects) {
      if (!bioprojects[bioproject]) continue;
      const samples = [...bioprojects[bioproject]];
      sort_samples(samples);
      for (const sample of samples) {
        if (country_search.value &&
            (!sample_metadata[sample].country ||
             !sample_metadata[sample].country.toLowerCase().includes(
               country_search.value.toLowerCase()))) {
          continue;
        }
        if (city_search.value &&
            (!sample_metadata[sample].location ||
             !sample_metadata[sample].location.toLowerCase().includes(
               city_search.value.toLowerCase()))) {
          continue;
        }
        if (target_date_begin || target_date_end) {
          if (!sample_metadata[sample].date) continue;

          let date_as_begin = clean_date(sample_metadata[sample].date,
                                         /*is_begin=*/true);
          let date_as_end = clean_date(sample_metadata[sample].date,
                                       /*is_begin=*/false);

          if (target_date_begin && date_as_begin < target_date_begin) {
            continue;
          }
          if (target_date_end && date_as_end > target_date_end) {
            continue;
          }
        }

        samples_list.push([sample]);
      }
    }
  }
  return samples_list;
}

function sort_samples(samples) {
  samples.sort(function(sample1, sample2) {
    // sort by country, then location, then fine_location, then date
    if (sample_metadata[sample1].country !=
        sample_metadata[sample2].country) {
      return sample_metadata[sample1].country <
        sample_metadata[sample2].country;
    }
    if (sample_metadata[sample1].location !=
        sample_metadata[sample2].location) {
      return sample_metadata[sample1].location <
        sample_metadata[sample2].location;
    }
    if (sample_metadata[sample1].fine_location !=
        sample_metadata[sample2].fine_location) {
      return sample_metadata[sample1].fine_location <
        sample_metadata[sample2].fine_location;
    }
    if (sample_metadata[sample1].date !=
        sample_metadata[sample2].date) {
      return sample_metadata[sample1].date <
        sample_metadata[sample2].date;
    }
    return sample_metadata[sample1].reads - sample_metadata[sample2].reads;
  });
}

// The general design here is that every time something changes we
// throw away the whole table and make a new one based on the current state.
function redisplay() {
  update_paper_visibility();

  // Remove any table contents from before.
  while (tbl.firstChild) {
    tbl.removeChild(tbl.firstChild);
  }

  // For each column, what samples does it represent?
  const column_samples = [];
  // And how many reads is it, so we can compute relative abundances?
  const column_totals = [];

  const tr_header = e("tr");
  tr_header.classList.add("header");
  const td_refresh = e("td");
  const button_refresh_taxonomic_expansion = e("button", "\u27F3");
  button_refresh_taxonomic_expansion.onclick = refresh_taxonomic_expansion;
  td_refresh.appendChild(button_refresh_taxonomic_expansion);
  tr_header.appendChild(td_refresh);
  tr_header.appendChild(e("td"));  // taxonomic node names

  for (const paper_name of paper_names) {
    if (!paper_trs[paper_name]?.checkbox.checked ||
        paper_trs[paper_name]?.hidden) continue;

    const th_paper = e("th");
    const a_paper = e("a", paper_name.replaceAll(" ", "\u00a0"));
    a_paper.href = papers[paper_name].link;
    a_paper.target = "_blank";

    th_paper.appendChild(a_paper);
    th_paper.appendChild(e("br"));

    // Clicking it repeatedly expands until you're down to the sample
    // level.
    const expansion_options = paper_expansion_options(paper_name);
    if (expansion_options.length > 0) {
      if (paper_expansion(paper_name) != "sample") {
        const button_paper_expand = e("button", "+");
        button_paper_expand.paper_name = paper_name;
        button_paper_expand.onclick = expand_paper;
        th_paper.appendChild(button_paper_expand);
      }
      if (paper_expansion(paper_name) != expansion_options[0]) {
        const button_paper_collapse = e("button", "\u2212");
        button_paper_collapse.paper_name = paper_name;
        button_paper_collapse.onclick = collapse_paper;
        th_paper.appendChild(button_paper_collapse);
      }
    }

    let colspan = 0;
    for (const samples of categorize_samples_at_current_expansion(paper_name)) {
      colspan++;
      column_samples.push(samples);
    }
    if (colspan > 0) {
      tr_header.appendChild(th_paper);
      th_paper.colSpan = colspan;
    }
  }
  tbl.appendChild(tr_header);

  for (const [property, plural] of [
    ["country", "countries"],
    ["location", "cities"],
    ["fine_location", "sites"],
    ["date", "dates"],
    ["samples", "samples"],
    ["reads", "reads"]]) {

    const tr = e("tr");
    tr.classList.add("header");
    tr.classList.add("details");
    tr.appendChild(e("td")); // expansion button
    tr.appendChild(e("td")); // taxonomic name
    let prev_val = null;
    for (const samples of column_samples) {
      if (property == "samples") {
        if (samples.length == 1) {
          const a_sample = e("a", samples[0]);
          a_sample.href = "https://www.ebi.ac.uk/ena/browser/view/" + samples[0];
          a_sample.target = "_blank";
          const td_sample = e("td");
          td_sample.appendChild(a_sample);
          tr.appendChild(td_sample);
        } else {
          tr.appendChild(e("td", samples.length + " " + plural));
        }
      } else if (property == "reads") {
        let total_reads = 0;
        for (const sample of samples) {
          total_reads += sample_metadata[sample].reads;
        }
        column_totals.push(total_reads);
        tr.appendChild(e("td", human_readable(total_reads) + " " + plural));
      } else {
        const vals = new Set();
        for (const sample of samples) {
          if (sample_metadata[sample][property]) {
            vals.add(sample_metadata[sample][property]);
          }
        }
        if (vals.size == 1 && [...vals][0] == prev_val) {
          tr.appendChild(e("td", "\u3003"));
        } else {
          prev_val = null;
          if (vals.size == 0) {
            tr.appendChild(e("td"));
          } else if (vals.size == 1) {
            tr.appendChild(e("td", [...vals][0]));
            prev_val = [...vals][0];
          } else {
            tr.appendChild(e("td", vals.size + " " + plural));
          }
        }
      }
    }
    tbl.appendChild(tr);
  }

  // First find out which taxonomic nodes should be shown, then
  // identify all their ancestors, then populate them.
  const visible_taxonomic_nodes = new Set();
  if (taxonomic_search.value) {
    for (const taxid in names) {
      for (const name of names[taxid]) {
        if (name.toLowerCase().includes(
            taxonomic_search.value.toLowerCase())) {
          visible_taxonomic_nodes.add(Number(taxid));
          break;
        }
      }
    }
  } else {
    for (const taxid in names) {
      for (const name of names[taxid]) {
        if (name == "Viruses") {
          visible_taxonomic_nodes.add(Number(taxid));
        }
      }
    }
  }

  function handle_manual_expansion(node=tree) {
    const taxid = node[0];
    if (manually_expanded_taxids.has(taxid)) {
      for (let i = 1; i < node.length; i++) {
        visible_taxonomic_nodes.add(node[i][0]);
      }
    }
    for (let i = 1; i < node.length; i++) {
      handle_manual_expansion(node[i]);
    }
  }
  handle_manual_expansion();

  function build_subtree(node) {
    const taxid = node[0];
    const filtered_node = [taxid];

    if (node.length > 1) {
      for (let i = 1; i < node.length; i++) {
        const potential_child = build_subtree(node[i]);
        if (potential_child) {
          filtered_node.push(potential_child);
          visible_taxonomic_nodes.add(taxid);
        }
      }
    }

    if (visible_taxonomic_nodes.has(taxid) || filtered_node.length > 1) {
      return filtered_node;
    }
    return null;
  }
  const subtree = build_subtree(tree);

  function expand_all_species(node, all_species) {
    const taxid = node[0];
    if (node.length == 1) {
      all_species.push(taxid);
    }
    for (let i = 1; i < node.length; i++) {
      expand_all_species(node[i], all_species);
    }
  }

  function expand_species(target_taxid, node=tree) {
    const taxid = node[0];
    if (taxid == target_taxid) {
      const all_species = [];
      expand_all_species(node, all_species);
      return all_species;
    } else {
      for (let i = 1; i < node.length; i++) {
        const maybe_species = expand_species(target_taxid, node[i]);
        if (maybe_species) {
          return maybe_species;
        }
      }
    }
    return null;
  }

  function count_matches(samples, all_species) {
    let total = 0;
    const matching_samples = new Set();
    for (const species of all_species) {
      for (const sample of samples) {
        const n = virus_sample_counts?.[species]?.[sample];
        if (n) {
          total += n;
          matching_samples.add(sample);
        }
      }
    }
    return [total, matching_samples];
  }

  // -> name, is_match
  function name_node(taxid) {
    let name = names[taxid][0];

    const target_lower = taxonomic_search.value.toLowerCase();
    if (!target_lower) return [name, false];

    if (name.toLowerCase().includes(target_lower)) {
      return [name, true];
    }
    if (!name.toLowerCase().includes(target_lower)) {
      for (const alt_name of names[taxid]) {
        if (alt_name.toLowerCase().includes(target_lower)) {
          return [name +  " (" + alt_name + ")", true];
        }
      }
    }
    return [name, false];
  }

  function has_nonvisible_children(target_taxid, node=tree) {
    const taxid = node[0];
    if (target_taxid == taxid) {
      for (let i = 1; i < node.length; i++) {
        if (!visible_taxonomic_nodes.has(node[i][0])) {
          return true;
        }
      }
      return false;
    }
    for (let i = 1; i < node.length; i++) {
      if (has_nonvisible_children(target_taxid, node[i])) {
        return true;
      }
    }
    return false;
  }

  function render_subtree(node=subtree, depth=0) {
    if (!node || !node.length) return;

    const tr = e("tr");
    const taxid = node[0];

    const td_expand_button = e("td");
    // button should be present if any children of this node are not
    // currently expanded.
    if (has_nonvisible_children(taxid)) {
      const button_expand = e("button", "+");
      button_expand.onclick = function () { manually_expand(taxid) };
      td_expand_button.appendChild(button_expand);
    }
    tr.appendChild(td_expand_button);

    const td_node_name = e("td");
    td_node_name.style.paddingLeft = (depth*0.5) + "em";
    const [node_name, is_match] = name_node(taxid);
    const a_node_name = e("a", node_name);
    if (is_match) {
      td_node_name.style.backgroundColor = 'lightyellow';
    }
    a_node_name.href =
      "https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi" +
      "?lvl=0&id=" + taxid;
    a_node_name.target = "_blank";
    td_node_name.appendChild(a_node_name);
    // hovertext showing alternative names
    td_node_name.title = names[taxid].length > 1 ?
      names[taxid].slice(1).join(", ") : names[taxid][0];
    tr.appendChild(td_node_name);

    const species = expand_species(taxid);
    for (let i = 0; i < column_samples.length; i++) {
      const samples = column_samples[i];
      const total_reads = column_totals[i];
      const [matches, matching_samples] = count_matches(samples, species);
      const td_val = e("td");
      const label = cell_value(matches, total_reads, node.length==1);
      if (matching_samples.size == 1) {
        const a_val = e("a", label);
        const params = new URLSearchParams();
        params.set("q", names[taxid][0]);
        params.set("run", [...matching_samples][0]);
        a_val.href = "reads#" + params.toString();
        a_val.target = "_blank";
        td_val.appendChild(a_val);
      } else {
        td_val.innerText = label;
      }
      td_val.style.backgroundColor = sci_color(matches/total_reads);
      tr.appendChild(td_val);
    }
    if (taxid != 1) {
      tbl.appendChild(tr);
    }
    for (let i = 1; i < node.length; i++) {
      render_subtree(node[i], depth+1);
    }
  }

  render_subtree();

  loading.style.display = "none";
}

let active_followups = 0;

// When someone is typing quickly we don't want to search repeatedly.
function search_followup() {
  active_followups--;
  if (active_followups) return;

  redisplay();
}

function search(e) {
  check_input_errors();
  update_hash();
  active_followups++;
  if (e.target.value.length > 3 ||
      e.target == na_search ||
      e.target == min_reads_search) {
    setTimeout(search_followup, 100);
  } else {
    setTimeout(search_followup, 1000);
  }
}

na_search.addEventListener("input", search);
min_reads_search.addEventListener("input", search);

taxonomic_search.addEventListener("input", search);

country_search.addEventListener("input", search);
city_search.addEventListener("input", search);
date_begin_search.addEventListener("input", search);
date_end_search.addEventListener("input", search);

if (window.location.hash) {
  const params = new URLSearchParams(window.location.hash.slice(1));
  if (params.has("q")) {
    taxonomic_search.value = params.get("q");
  }
  if (params.has("country")) {
    country_search.value = params.get("country");
  }
  if (params.has("city")) {
    city_search.value = params.get("city");
  }
  if (params.has("date_begin")) {
    date_begin_search.value = params.get("date_begin");
  }
  if (params.has("date_end")) {
    date_end_search.value = params.get("date_end");
  }
}

function update_hash() {
  const params = new URLSearchParams();
  if (taxonomic_search.value) {
    params.set("q", taxonomic_search.value);
  }
  if (country_search.value) {
    params.set("country", country_search.value);
  }
  if (city_search.value) {
    params.set("city", city_search.value);
  }
  if (date_begin_search.value) {
    params.set("date_begin", date_begin_search.value);
  }
  if (date_end_search.value) {
    params.set("date_end", date_end_search.value);
  }
  window.location.hash = params.toString();
}

redisplay();

</script>
