<!--

To rebuild:
1. Run mgs pipeline
2. dashboard/prepare-dashboard-data.sh makes data.js

-->

<title>Viral Counts Explorer</title>
<h1>Viral Counts Explorer</h1>

<div id=loading>
loading...
</div>

<p>

This tool displays a summary of the output of the <a
href="https://www.naobservatory.org/">NAO</a> metagenomic sequencing
pipeline (<a
href="https://github.com/naobservatory/mgs-pipeline">code</a>).

<p>

<div class=search_box>
Limit Papers:

<p>

<table>
  <tr><td>Nucleic Acid<td><input id=na_paper_search type=text size=34></input>
  <tr><td>Min reads<td><input size=5 value=1e1 id=min_reads_search
          type=text></input>
  <!-- todo: once we have more categorizations on the papers (enrichment?
       filtration? sample type?) these can go here -->
</table>
</div>

  <p>


<table id=table_papers cellpadding=5 rules=rows>
  <tr><th><input type=checkbox checked id=checkbox_all_papers><th>Name<th>Reads<th>Acid<th>Samples<th>Subset<th>Location<th>Date<th>Bioprojects
</table>

<p>

<div class=search_box>

Search human-infecting viruses: <input id=taxonomic_search type=text size=34></input>

<p>

Comparison clades:

  <p>

  <table>
  <tr><td>Search<td><input
          id=comparison_search type=text size=34></input>
  <tr><td>Common<td>
     <input type=checkbox checked id=comparison_viruses>
     <label for=comparison_viruses>Viruses</label><br>
     <input type=checkbox checked id=comparison_bacteria>
     <label for=comparison_bacteria>Bacteria</label><br>
     <input type=checkbox checked id=comparison_other>
     <label for=comparison_other>Other</label>
  </table>

  <p>
  <br>

Limit Samples:
<p>
<table>
  <tr><td>Country<td><input id=country_search type=text size=34></input>
  <tr><td>City<td><input id=city_search type=text size=34></input>
  <tr><td>Nucleic Acid<td>
    <input type="checkbox" checked
           id="na_sample_dna"
           name="na_type"
           value="dna">
    <label for="na_sample_dna">DNA</label><br>
    <input type="checkbox" checked
           id="na_sample_rna"
           name="na_type"
           value="rna">
    <label for="na_sample_viral">RNA</label><br>
    <input type="checkbox" checked
           id="na_sample_dna_rna"
           name="na_type"
           value="dna_rna">
    <label for="na_sample_panel">DNA+RNA</label><br>


  <tr><td>Enrichment<td>
    <input type="checkbox" checked
           id="enrichment_none"
           name="enrichment"
           value="none">
    <label for="enrichment_none">None</label><br>
    <input type="checkbox" checked
           id="enrichment_viral"
           name="enrichment"
           value="viral">
    <label for="enrichment_viral">Viral</label><br>
    <input type="checkbox"
           id="enrichment_panel"
           name="enrichment"
           value="panel">
    <label for="enrichment_panel">Panel</label><br>

  <tr><td>Date<td>
  <input size=15 id=date_begin_search type=text></input> &ndash;
     <input size=15 id=date_end_search type=text></input>
</table>
</div>

<p>
Rows are clades, columns are samples, cells are relative abundances and counts.
<p>


<table id=tbl></table>
<style>
  #tbl td {
    word-wrap: break-word;
    max-width: 15em;
    min-width: 1em;
    padding: 0.5em;
  }
  #tbl tr {
    border-top: 1px solid black;
  }
  #tbl .header {
    border-top: none;
  }
  #tbl .header td {
    padding: 0.1em;
    padding-right: 0.5em;
  }
  tr {
    vertical-align: top;
  }
  th {
    text-align: left;
    padding-right: 0.5em;
  }
  .details {
    background-color: #eee;
  }
  #tbl {
    border-collapse: collapse;
  }
  .search_box {
    border: 1px solid black;
    border-radius: 0.5em;
    padding: 1em;
    display: inline-block;
  }
  .error {
    border: 1px solid red;
    color: red;
  }
  #loading {
    padding: 2em;
  }
</style>

<script src="data.js"></script>
<script>

// imports:
//   virus_sample_counts: human virus taxid -> sample -> direct assignments
//   comparison_sample_counts: other taxid -> sample -> clade assignments
//   comparison_taxid_classifications: bacteria/virus -> taxids
//   sample_metadata: sample -> {country, date, location, reads}
//   bioprojects: project -> [samples]
//   papers: paper -> {link, na_type, [projects]}
//   names: taxid -> name
//   tree: taxid with children

window.onerror = function () {
  document.body.style.border = "5px solid red";
  document.body.style.borderRadius = "1em";
};

names[0] = ["Unassigned"];

const paper_names = [];
for (const paper in papers) {
  paper_names.push(paper);
}
paper_names.sort();

for (const sample in sample_metadata) {
  if (sample_metadata[sample].date == "Summer 2013") {
    // Make it sort properly.
    sample_metadata[sample].date = "2013-Summer";
  }
}

const paper_countries = {};
const paper_locations = {};
const paper_fine_locations = {};
const paper_dates = {};

const VIRUS = 10239;
const BACTERIA = 2;

// taxid
const active_comparisons = new Set();
const pinned_comparisons = new Set();

for (const paper_name of paper_names) {
  paper_countries[paper_name] = new Set();
  paper_locations[paper_name] = new Set();
  paper_fine_locations[paper_name] = new Set();
  paper_dates[paper_name] = new Set();

  for (const bioproject of papers[paper_name].projects) {
    if (!bioprojects[bioproject]) continue;
    for (const sample of bioprojects[bioproject]) {
      paper_countries[paper_name].add(sample_metadata[sample].country);
      paper_locations[paper_name].add(sample_metadata[sample].location);
      if (sample_metadata[sample].fine_location) {
        paper_fine_locations[paper_name].add(
          sample_metadata[sample].fine_location);
      }
      if (sample_metadata[sample].date) {
        paper_dates[paper_name].add(sample_metadata[sample].date);
      }
      if (!sample_metadata[sample].na_type) {
        sample_metadata[sample].na_type = papers[paper_name].na_type;
      }
    }
  }
}

function paper_expansion_options(paper_name) {
  const options = [];
  options.push("collapsed");
  if (paper_countries[paper_name].size > 1) {
    options.push("country");
  }
  if (paper_locations[paper_name].size > paper_countries[paper_name].size) {
    options.push("location");
  }
  if (paper_fine_locations[paper_name].size > 1) {
    options.push("fine");
  }
  options.push("sample");
  return options;
}

function summarize_location(paper_name) {
  if (paper_countries[paper_name].size == 1 &&
      paper_locations[paper_name].size == 1) {
    const [location] = paper_locations[paper_name];
    return location;
  }
  if (paper_countries[paper_name].size == 1) {
    const [country] = paper_countries[paper_name];
    return country;
  }
  return "Multiple";
}

function summarize_date(paper_name) {
  if (paper_name == "Petersen 2015" &&
      [...paper_dates[paper_name]][0] == "2013-Summer") {
    // We don't know which sample is which date, but we do know the
    // overall range.
    return "2013-06 to 2013-08";
  }

  if (paper_dates[paper_name].size == 1) {
    const [date] = paper_dates[paper_name];
    return date;
  }

  const sorted_dates = [...paper_dates[paper_name]].sort();

  let first = sorted_dates[0];
  let last = sorted_dates[sorted_dates.length - 1];

  // If one of our bounds is year-only, truncate the other to the year
  // as well.
  if (/^20\d\d$/.test(first) && /^20\d\d.*/.test(last)) {
    last = last.substring(0, 4);
  } else if (/^20\d\d$/.test(last) && /^20\d\d.*/.test(first)) {
    first = first.substring(0, 4);
  }

  if (first.substring(0, 4) != last.substring(0, 4)) {
    // When dates span years, just use the years.
    first = first.substring(0, 4);
    last = last.substring(0, 4);
  } else if (first.substring(0, 7) != last.substring(0, 7)) {
    // When same-year dates span months, just use the months.
    first = first.substring(0, 7);
    last = last.substring(0, 7);
  }

  return first + " to " + last;
}

function sample_description(target_sample, paper_name) {
  const name_bits = [];
  name_bits.push(sample_metadata[target_sample].country || "Unknown");
  if (sample_metadata[target_sample].location) {
    name_bits.push(sample_metadata[target_sample].location);
  }
  if (sample_metadata[target_sample].fine_location) {
    name_bits.push(sample_metadata[target_sample].fine_location);
  }
  if (sample_metadata[target_sample].date) {
    name_bits.push(sample_metadata[target_sample].date);
  }
  return name_bits;
}


const paper_trs = {}; // paper -> row in papers table

function is_sci_num(s) {
  return /^\d+e\d+$/.test(s);
}

function check_input_errors() {
  if (min_reads_search.value && !is_sci_num(min_reads_search.value)) {
    min_reads_search.classList.add("error");
  } else {
    min_reads_search.classList.remove("error");
  }
}

function update_paper_visibility() {
  for (const paper_tr of Object.values(paper_trs)) {
    paper_tr.hidden = false;
    if (!paper_tr.na_type.toLowerCase().includes(
        na_paper_search.value.toLowerCase())) {
      paper_tr.hidden = true;
    }
    if (min_reads_search.value &&
        is_sci_num(min_reads_search.value) &&
        paper_tr.total_reads < parseFloat(min_reads_search.value)) {
      paper_tr.hidden = true;
    }
  }
}

for (const paper_name of paper_names) {
  const tr = e("tr");

  const td_include = e("td");
  const input_include = e("input");
  input_include.type = "checkbox";
  input_include.checked = true;
  input_include.onchange = redisplay;
  td_include.appendChild(input_include);
  tr.appendChild(td_include);

  const td_name = e("td");
  const a_name = e("a", paper_name);
  a_name.href = papers[paper_name].link;
  a_name.target = "_blank";
  td_name.appendChild(a_name);
  tr.appendChild(td_name);

  let total_reads = 0;
  let total_samples = 0;
  for (const bioproject of papers[paper_name].projects) {
    if (!bioprojects[bioproject]) continue;
    for (const sample of bioprojects[bioproject]) {
      total_reads += sample_metadata[sample].reads;
      total_samples += 1;
    }
  }

  if (total_reads == 0) {
    continue;
  }

  tr.checkbox = input_include;
  tr.total_reads = total_reads;
  tr.na_type = papers[paper_name].na_type;
  tr.hidden = false;

  tr.appendChild(e("td", human_readable(total_reads) + " reads"));
  const td_na_type = e("td");
  for (const na_type of papers[paper_name].na_type.split("+")) {
    td_na_type.appendChild(e("div", na_type));
  }
  tr.appendChild(td_na_type);
  tr.appendChild(e("td", total_samples));
  tr.appendChild(e("td", papers[paper_name].subset || ""));
  tr.appendChild(e("td", summarize_location(paper_name)));
  tr.appendChild(e("td", summarize_date(paper_name)));

  const td_bioprojects = e("td");
  for (const bioproject of papers[paper_name].projects) {
    const a_bioproject = e("a", bioproject);
    a_bioproject.href = "https://www.ebi.ac.uk/ena/browser/view/" + bioproject;
    a_bioproject.target = "_blank";
    td_bioprojects.appendChild(a_bioproject);
    td_bioprojects.appendChild(e("br"));
  }
  tr.appendChild(td_bioprojects);

  table_papers.appendChild(tr);
  paper_trs[paper_name] = tr;
}

function e(tag, innerText) {
  const el = document.createElement(tag);
  if (innerText) {
    el.innerText = innerText;
  }
  return el;
}

function clean_date(raw_date, is_begin) {
  if (!raw_date) return null;

  if (raw_date == "2013-Summer") {
    // Special casing Petersen 2015.
    if (is_begin) {
      return "2013-06";
    }
    return "2013-08";
  }

  if (/^20\d\d$/.test(raw_date)) {
    if (is_begin) {
      return raw_date += "-01-01";
    }
    return raw_date += "-12-31";
  }
  if (/^20\d\d-\d\d$/.test(raw_date)) {
    if (is_begin) {
      return raw_date += "-01";
    }
      return raw_date + "-31";
  }
  if (/^20\d\d-\d\d-\d\d$/.test(raw_date)) {
    return raw_date;
  }
  return null;
}

function human_readable(n) {
  function s(v, suffix) {
    let vStr = v.toPrecision(3);
    if (vStr.includes(".")) {
      vStr = v.toPrecision(2);
    }
    return vStr + suffix;
  }
  if (n < 1000) return n;
  n /= 1000;
  if (n < 1000) return s(n,'k');
  n /= 1000;
  if (n < 1000) return s(n,'M');
  n /= 1000;
  if (n < 1000) return s(n, 'B');
  n /= 1000;
  if (n < 1000) return s(n, 'T');
  n /= 1000;
  return s(n, 'Q');
}

function cell_value(count, total) {
  if (count == 0) {
    return "< " + sci_num(1/total) + " (0)";
  }
  const val = count / total;
  const pretty_count = count < 1000 ? count : sci_num(count);
  const pretty_val = val >= 0.0001 ? ((val*100).toPrecision(2) + "%") : sci_num(val);
  return pretty_val + " (" + pretty_count + ")";
}

function sci_num(x) {
  return x.toExponential(1);
}

function human_virus_color(x) {
  if (x > 1e-5) {
    return '#f9f';
  } else if (x > 1e-6) {
    return '#faf';
  } else if (x > 1e-7) {
    return '#fbf';
  } else if (x > 1e-8) {
    return '#fcf';
  } else if (x > 1e-9) {
    return '#fdf';
  } else if (x > 1e-10) {
    return '#fef';
  }
  return '#fff';
}

function comparison_color(x) {
  if (x > 1e-1) {
    return '#00ffff';
  } else if (x > 1e-2) {
    return '#50ffff';
  } else if (x > 1e-3) {
    return '#a0ffff';
  } else if (x > 1e-4) {
    return '#b0ffff';
  } else if (x > 1e-5) {
    return '#c0ffff';
  } else if (x > 1e-6) {
    return '#c8ffff';
  } else if (x > 1e-7) {
    return '#d0fbff';
  } else if (x > 1e-8) {
    return '#d8ffff';
  } else if (x > 1e-9) {
    return '#e0ffff';
  } else if (x > 1e-10) {
    return '#e8ffff';
  }
  return '#fff';
}

const rightTriangle = "&rarr;";
const downTriangle = "&darr;";

const manually_expanded_taxids = new Set();

function manually_expand(taxid) {
  manually_expanded_taxids.add(taxid);
  redisplay();
}

function manually_collapse(taxid) {
  manually_expanded_taxids.delete(taxid);
  redisplay();
}

function refresh_taxonomic_expansion() {
  manually_expanded_taxids.clear();
  redisplay();
}

function expand_paper(e) {
  const paper_name = e.target.paper_name;
  const options = paper_expansion_options(paper_name);
  const current_level = paper_expansion(paper_name);
  paper_expansions[paper_name] = options[options.indexOf(current_level) + 1];
  redisplay();
}

function collapse_paper(e) {
  const paper_name = e.target.paper_name;
  const options = paper_expansion_options(e.target.paper_name);

  const current_option_index = options.indexOf(
    paper_expansions[paper_name]);
  if (current_option_index == 0) {
    delete paper_expansions[paper_name];
  } else {
    paper_expansions[paper_name] = options[current_option_index - 1];
  }
  redisplay();
}

checkbox_all_papers.onchange = function() {
  for (paper_name of paper_names) {
    if (paper_trs[paper_name]?.checkbox) {
      paper_trs[paper_name].checkbox.checked = checkbox_all_papers.checked;
    }
  }
  redisplay();
}

const expansion_levels = ["collapsed", "country", "location", "fine", "sample"];

// paper_name -> expansion level
const paper_expansions = {}
for (paper_name of paper_names) {
  paper_expansions[paper_name] = "collapsed";
}

function paper_expansion(paper_name) {
  return paper_expansions[paper_name];;
}

function exclude_sample(sample, target_date_begin, target_date_end) {
  if (!na_sample_dna.checked && sample_metadata[sample].na_type == "DNA") {
    return true;
  }
  if (!na_sample_rna.checked && sample_metadata[sample].na_type == "RNA") {
    return true;
  }
  if (!na_sample_dna_rna.checked &&
      sample_metadata[sample].na_type == "DNA+RNA") {
    return true;
  }

  const enrichment = sample_metadata[sample].enrichment;
  if (enrichment == "viral" && !enrichment_viral.checked) return true;
  if (enrichment == "panel" && !enrichment_panel.checked) return true;
  if (!enrichment && !enrichment_none.checked) return true;

  if (country_search.value) {
    const country = sample_metadata[sample].country;
    if (!country || !country.toLowerCase().includes(
      country_search.value.toLowerCase())) return true;
  }

  if (city_search.value) {
    const city = sample_metadata[sample].location;
    if (!city || !city.toLowerCase().includes(
      city_search.value.toLowerCase())) return true;
  }

  if (target_date_begin || target_date_end) {
    if (!sample_metadata[sample].date) return true;
    const date_as_begin = clean_date(sample_metadata[sample].date,
                                   /*is_begin=*/true);
    const date_as_end = clean_date(sample_metadata[sample].date,
                                 /*is_begin=*/false);

    if (target_date_begin && date_as_begin < target_date_begin) {
      return true;
    }
    if (target_date_end && date_as_end > target_date_end) {
      return true;
    }
  }

  return false;
}

// -> [samples, ...]
function categorize_samples_at_current_expansion(paper_name) {
  let target_date_begin = clean_date(date_begin_search.value,
                                     /*is_begin=*/true);
  let target_date_end = clean_date(date_end_search.value,
                                   /*is_begin=*/false);

  const samples_list = [];
  if (paper_expansion(paper_name) == "collapsed") {
    const samples = [];
    for (const bioproject of papers[paper_name].projects) {
      if (!bioprojects[bioproject]) continue;
      for (const sample of bioprojects[bioproject]) {
        if (exclude_sample(sample, target_date_begin, target_date_end)) continue;
        samples.push(sample)
      }
    }
    sort_samples(samples);
    samples_list.push(samples);
  } else if (paper_expansion(paper_name) == "country") {
    for (const country of [...paper_countries[paper_name]].sort()) {
      const samples = [];
      for (const bioproject of papers[paper_name].projects) {
        if (!bioprojects[bioproject]) continue;
        for (const sample of bioprojects[bioproject]) {
          if (sample_metadata[sample].country == country) {
            if (exclude_sample(sample, target_date_begin, target_date_end)) {
              continue;
            }
            samples.push(sample);
          }
        }
      }
      sort_samples(samples);
      samples_list.push(samples);
    }
  } else if (paper_expansion(paper_name) == "location") {
    for (const country of [...paper_countries[paper_name]].sort()) {
      for (const location of [...paper_locations[paper_name]].sort()) {
        const samples = [];
        for (const bioproject of papers[paper_name].projects) {
          if (!bioprojects[bioproject]) continue;
          for (const sample of bioprojects[bioproject]) {

            if (sample_metadata[sample].country == country &&
                sample_metadata[sample].location == location) {

              if (exclude_sample(sample, target_date_begin, target_date_end)) {
                continue;
              }
              samples.push(sample);
            }
          }
        }
        if (samples.length) {
          sort_samples(samples);
          samples_list.push(samples);
        }
      }
    }
  } else if (paper_expansion(paper_name) == "fine") {
    for (const country of [...paper_countries[paper_name]].sort()) {
      for (const location of [...paper_locations[paper_name]].sort()) {
        for (const fine_location of
             [...paper_fine_locations[paper_name]].sort()) {
          const samples = [];
          for (const bioproject of papers[paper_name].projects) {
            if (!bioprojects[bioproject]) continue;
            for (const sample of bioprojects[bioproject]) {
              if (sample_metadata[sample].country == country &&
                  sample_metadata[sample].location == location &&
                  sample_metadata[sample].fine_location == fine_location) {

                if (exclude_sample(sample, target_date_begin, target_date_end)) {
                  continue;
                }
                samples.push(sample);
              }
            }
          }
          if (samples.length) {
            sort_samples(samples);
            samples_list.push(samples);
          }
        }
      }
    }
  } else if (paper_expansion(paper_name) == "sample") {
    for (const bioproject of papers[paper_name].projects) {
      if (!bioprojects[bioproject]) continue;
      const samples = [...bioprojects[bioproject]];
      sort_samples(samples);
      for (const sample of samples) {
        if (exclude_sample(sample, target_date_begin, target_date_end)) continue;
        samples_list.push([sample]);
      }
    }
  }
  return samples_list;
}

function sort_samples(samples) {
  samples.sort(function(sample1, sample2) {
    // sort by country, then location, then fine_location, then date, then id
    if (sample_metadata[sample1].country !=
        sample_metadata[sample2].country) {
      return sample_metadata[sample1].country <
        sample_metadata[sample2].country;
    }
    if (sample_metadata[sample1].location !=
        sample_metadata[sample2].location) {
      return sample_metadata[sample1].location <
        sample_metadata[sample2].location;
    }
    if (sample_metadata[sample1].fine_location !=
        sample_metadata[sample2].fine_location) {
      return sample_metadata[sample1].fine_location <
        sample_metadata[sample2].fine_location;
    }
    if (sample_metadata[sample1].date !=
        sample_metadata[sample2].date) {
      return sample_metadata[sample1].date <
        sample_metadata[sample2].date;
    }
    return sample1 < sample2;
  });
}

// The general design here is that every time something changes we
// throw away the whole table and make a new one based on the current state.
function redisplay() {
  update_paper_visibility();

  // Remove any table contents from before.
  while (tbl.firstChild) {
    tbl.removeChild(tbl.firstChild);
  }

  active_comparisons.clear();
  if (comparison_search.value) {
    for (const taxid in comparison_sample_counts) {
      for (const name of names[taxid]) {
        if (name.toLowerCase().includes(
          comparison_search.value.toLowerCase())) {
          active_comparisons.add(taxid);
        }
      }
    }
  }
  for (const taxid of pinned_comparisons) {
    active_comparisons.add(taxid);
  }

  // For each column, what samples does it represent?
  const column_samples = [];
  // And how many reads is it, so we can compute relative abundances?
  const column_totals = [];

  const tr_header = e("tr");
  tr_header.classList.add("header");
  const td_refresh = e("td");
  const button_refresh_taxonomic_expansion = e("button", "\u27F3");
  button_refresh_taxonomic_expansion.onclick = refresh_taxonomic_expansion;
  td_refresh.appendChild(button_refresh_taxonomic_expansion);
  tr_header.appendChild(td_refresh);
  tr_header.appendChild(e("td"));  // taxonomic node names

  for (const paper_name of paper_names) {
    if (!paper_trs[paper_name]?.checkbox.checked ||
        paper_trs[paper_name]?.hidden) continue;

    const th_paper = e("th");
    const a_paper = e("a", paper_name.replaceAll(" ", "\u00a0"));
    a_paper.href = papers[paper_name].link;
    a_paper.target = "_blank";

    th_paper.appendChild(a_paper);
    th_paper.appendChild(e("br"));

    // Clicking it repeatedly expands until you're down to the sample
    // level.
    const expansion_options = paper_expansion_options(paper_name);
    if (expansion_options.length > 0) {
      if (paper_expansion(paper_name) != "sample") {
        const button_paper_expand = e("button", "+");
        button_paper_expand.paper_name = paper_name;
        button_paper_expand.onclick = expand_paper;
        th_paper.appendChild(button_paper_expand);
      }
      if (paper_expansion(paper_name) != expansion_options[0]) {
        const button_paper_collapse = e("button", "\u2212");
        button_paper_collapse.paper_name = paper_name;
        button_paper_collapse.onclick = collapse_paper;
        th_paper.appendChild(button_paper_collapse);
      }
    }

    let colspan = 0;
    for (const samples of categorize_samples_at_current_expansion(paper_name)) {
      if (!samples.length) continue;
      colspan++;
      column_samples.push(samples);
    }
    if (colspan > 0) {
      tr_header.appendChild(th_paper);
      th_paper.colSpan = colspan;
    }
  }
  tbl.appendChild(tr_header);

  for (const [property, plural] of [
    ["na_type", "acid"],
    ["country", "countries"],
    ["location", "cities"],
    ["fine_location", "sites"],
    ["date", "dates"],
    ["samples", "samples"],
    ["enrichment", "enrichments"],
    ["ribocounts", "rRNA"],
    ["reads", "reads"]]) {

    const tr = e("tr");
    tr.classList.add("header");
    tr.classList.add("details");
    tr.appendChild(e("td")); // expansion button
    tr.appendChild(e("td")); // taxonomic name
    let prev_val = null;
    for (const samples of column_samples) {
      if (property == "samples") {
        if (samples.length == 1) {
          const a_sample = e("a", samples[0]);
          a_sample.href = "https://www.ebi.ac.uk/ena/browser/view/" + samples[0];
          a_sample.target = "_blank";
          const td_sample = e("td");
          td_sample.appendChild(a_sample);
          tr.appendChild(td_sample);
        } else {
          tr.appendChild(e("td", samples.length + " " + plural));
        }
      } else if (property == "na_type") {
        const vals = new Set();
        for (const sample of samples) {
          if (sample_metadata[sample][property]) {
            vals.add(sample_metadata[sample][property]);
          }
        }

        const sorted_text_val = [...vals].sort().join(", ");
        if (sorted_text_val == prev_val) {
          tr.appendChild(e("td", "\u3003"));
        } else {
          tr.appendChild(e("td", sorted_text_val));
          prev_val = sorted_text_val;
        }
      } else if (property == "enrichment") {
        const vals = new Set();
        for (const sample of samples) {
          vals.add(sample_metadata[sample][property] || "none");
        }

        const sorted_text_val = [...vals].sort().join(", ");
        if (sorted_text_val == prev_val){
          tr.appendChild(e("td", "\u3003"));
        } else {
          tr.appendChild(e("td", sorted_text_val));
          prev_val = sorted_text_val;
        }
      } else if (property == "reads") {
        let total_reads = 0;
        for (const sample of samples) {
          total_reads += sample_metadata[sample].reads;
        }
        column_totals.push(total_reads);
        tr.appendChild(e("td", human_readable(total_reads) + " " + plural));
      } else if (property == "ribocounts") {
        let total_reads = 0;
        let total_ribocounts = 0;
        for (const sample of samples) {
          if (sample_metadata[sample].hasOwnProperty("ribocounts")) {
            total_reads += sample_metadata[sample].reads;
            total_ribocounts += sample_metadata[sample].ribocounts;
          }
        }
        tr.appendChild(e("td", (total_reads > 0 ? (
          (100 * total_ribocounts / total_reads).toFixed(1) + "%") : "--") + " " + plural));
      } else {
        const vals = new Set();
        for (const sample of samples) {
          if (sample_metadata[sample][property]) {
            vals.add(sample_metadata[sample][property]);
          }
        }
        if (vals.size == 1 && [...vals][0] == prev_val) {
          tr.appendChild(e("td", "\u3003"));
        } else {
          prev_val = null;
          if (vals.size == 0) {
            tr.appendChild(e("td"));
          } else if (vals.size == 1) {
            tr.appendChild(e("td", [...vals][0]));
            prev_val = [...vals][0];
          } else {
            tr.appendChild(e("td", vals.size + " " + plural));
          }
        }
      }
    }
    tbl.appendChild(tr);
  }

  // First find out which taxonomic nodes should be shown, then
  // identify all their ancestors, then populate them.
  const visible_taxonomic_nodes = new Set();
  if (taxonomic_search.value) {
    for (const taxid in names) {
      for (const name of names[taxid]) {
        if (name.toLowerCase().includes(
            taxonomic_search.value.toLowerCase())) {
          visible_taxonomic_nodes.add(Number(taxid));
          break;
        }
      }
    }
  } else {
    for (const taxid in names) {
      for (const name of names[taxid]) {
        if (name == "Viruses") {
          visible_taxonomic_nodes.add(Number(taxid));
        }
      }
    }
  }

  function handle_manual_expansion(node=tree) {
    const taxid = node[0];
    if (manually_expanded_taxids.has(taxid)) {
      for (let i = 1; i < node.length; i++) {
        visible_taxonomic_nodes.add(node[i][0]);
      }
    }
    for (let i = 1; i < node.length; i++) {
      handle_manual_expansion(node[i]);
    }
  }
  handle_manual_expansion();

  function build_subtree(node) {
    const taxid = node[0];
    const filtered_node = [taxid];

    if (node.length > 1) {
      for (let i = 1; i < node.length; i++) {
        const potential_child = build_subtree(node[i]);
        if (potential_child) {
          filtered_node.push(potential_child);
          visible_taxonomic_nodes.add(taxid);
        }
      }
    }

    if (visible_taxonomic_nodes.has(taxid) || filtered_node.length > 1) {
      return filtered_node;
    }
    return null;
  }
  const subtree = build_subtree(tree);

  function expand_all_species(node, all_species) {
    const taxid = node[0];
    all_species.push(taxid);
    for (let i = 1; i < node.length; i++) {
      expand_all_species(node[i], all_species);
    }
  }

  function expand_species(target_taxid, node=tree) {
    const taxid = node[0];
    if (taxid == target_taxid) {
      const all_species = [];
      expand_all_species(node, all_species);
      return all_species;
    } else {
      for (let i = 1; i < node.length; i++) {
        const maybe_species = expand_species(target_taxid, node[i]);
        if (maybe_species) {
          return maybe_species;
        }
      }
    }
    return null;
  }

  function count_matches(samples, all_species) {
    let total = 0;
    const matching_samples = new Set();
    for (const species of all_species) {
      for (const sample of samples) {
        const n = virus_sample_counts?.[species]?.[sample];
        if (n) {
          total += n;
          matching_samples.add(sample);
        }
      }
    }
    return [total, matching_samples];
  }

  // -> name, is_match
  function name_node(taxid, search_val) {
    let name = names[taxid][0];

    const target_lower = search_val.toLowerCase();
    if (!target_lower) return [name, false];

    if (name.toLowerCase().includes(target_lower)) {
      return [name, true];
    }
    if (!name.toLowerCase().includes(target_lower)) {
      for (const alt_name of names[taxid]) {
        if (alt_name.toLowerCase().includes(target_lower)) {
          return [name +  " (" + alt_name + ")", true];
        }
      }
    }
    return [name, false];
  }

  function has_nonvisible_children(target_taxid, node=tree) {
    const taxid = node[0];
    if (target_taxid == taxid) {
      for (let i = 1; i < node.length; i++) {
        if (!visible_taxonomic_nodes.has(node[i][0])) {
          return true;
        }
      }
      return false;
    }
    for (let i = 1; i < node.length; i++) {
      if (has_nonvisible_children(target_taxid, node[i])) {
        return true;
      }
    }
    return false;
  }

  function has_visible_children(target_taxid, node=tree) {
    const taxid = node[0];
    if (target_taxid == taxid) {
      for (let i = 1; i < node.length; i++) {
        if (visible_taxonomic_nodes.has(node[i][0])) {
          return true;
        }
      }
      return false;
    }
    for (let i = 1; i < node.length; i++) {
      if (has_visible_children(target_taxid, node[i])) {
        return true;
      }
    }
    return false;
  }

  function render_subtree(node=subtree, depth=0) {
    if (!node || !node.length) return;

    const tr = e("tr");
    const taxid = node[0];

    const td_expand_button = e("td");
    // button should be present if any children of this node are not
    // currently expanded.
    if (has_nonvisible_children(taxid)) {
      const button_expand = e("button", "+");
      button_expand.onclick = function () { manually_expand(taxid) };
      td_expand_button.appendChild(button_expand);
    } else if (has_visible_children(taxid)) {
      // TODO: exclude things that are expanded via search, since they
      // won't collapse if you click -.
      const button_collapse = e("button", "\u2212");
      button_collapse.onclick = function () { manually_collapse(taxid) };
      td_expand_button.appendChild(button_collapse);
    }
    tr.appendChild(td_expand_button);
    td_expand_button.style.paddingLeft = (depth*0.5) + "em";

    const td_node_name = e("td");
    td_node_name.style.paddingLeft = (depth*0.5) + "em";
    const [node_name, is_match] = name_node(taxid, taxonomic_search.value);
    const a_node_name = e("a", node_name);
    if (is_match) {
      td_node_name.style.backgroundColor = 'lightyellow';
    }
    a_node_name.href =
      "https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi" +
      "?lvl=0&id=" + taxid;
    a_node_name.target = "_blank";
    td_node_name.appendChild(a_node_name);
    // hovertext showing alternative names
    td_node_name.title = names[taxid].length > 1 ?
      names[taxid].slice(1).join(", ") : names[taxid][0];
    tr.appendChild(td_node_name);

    const species = expand_species(taxid);
    for (let i = 0; i < column_samples.length; i++) {
      const samples = column_samples[i];
      const total_reads = column_totals[i];
      const [matches, matching_samples] = count_matches(samples, species);
      const td_val = e("td");
      const label = cell_value(matches, total_reads);
      if (matching_samples.size == 1) {
        const a_val = e("a", label);
        const params = new URLSearchParams();
        params.set("q", names[taxid][0]);
        params.set("run", [...matching_samples][0]);
        a_val.href = "reads#" + params.toString();
        a_val.target = "_blank";
        td_val.appendChild(a_val);
      } else {
        td_val.innerText = label;
      }
      td_val.style.backgroundColor = human_virus_color(matches/total_reads);
      tr.appendChild(td_val);
    }

    if (taxid == VIRUS) { // viruses, root of tree
      add_divider("Human infecting viruses.  Counts on higher clades only " +
                  "include reads assigned to human-infecting viruses.  Format " +
                  "is 'relative_abundance (read count)'.");
    }

    if (taxid != 1) {
      tbl.appendChild(tr);
    }
    for (let i = 1; i < node.length; i++) {
      render_subtree(node[i], depth+1);
    }
  }

  render_subtree();

  const taxid_relab = [];  // [relative abundance, taxid]
  for (const taxid_str in comparison_sample_counts) {
    const taxid = Number(taxid_str);
    if (comparison_taxid_classifications[VIRUS].includes(Number(taxid))) {
      if (!comparison_viruses.checked) continue;
    } else if (comparison_taxid_classifications[BACTERIA].includes(taxid)) {
      if (!comparison_bacteria.checked) continue;
    } else {
      if (!comparison_other.checked) continue;
    }

    let n_reads = 0;
    let n_matches = 0;
    for (let i = 0; i < column_samples.length; i++) {
      n_reads += column_totals[i];
      for (const sample of column_samples[i]) {
        n_matches += comparison_sample_counts?.[taxid]?.[sample] || 0;
      }
    }
    if (n_matches > 0) {
      taxid_relab.push([n_matches / n_reads, taxid]);
    }
  }
  taxid_relab.sort(function(a, b){return b[0] - a[0]});
  for (let i = 0; i < 15 && i < taxid_relab.length; i++) {
    active_comparisons.add(taxid_relab[i][1]);
  }
  console.log(active_comparisons);

  function render_comparison_nodes() {
    let added_divider = false;
    for (const taxid of active_comparisons) {
      const tr = e("tr");
      const td_pin_button = e("td");
      const is_pinned = pinned_comparisons.has(taxid);
      const pin_button = e(
        "button", is_pinned ? "\uD83D\uDDD1" : "\uD83D\uDCCC");
      pin_button.onclick = function() {
        if (is_pinned) {
          pinned_comparisons.delete(taxid);
        } else {
          pinned_comparisons.add(taxid);
        }
        update_hash();
        redisplay();
      };
      td_pin_button.appendChild(pin_button);
      tr.appendChild(td_pin_button);
      const td_node_name = e("td");
      const [node_name, is_match] = name_node(taxid, comparison_search.value);
      const a_node_name = e("a", node_name);
      a_node_name.href =
        "https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi" +
        "?lvl=0&id=" + taxid;
      a_node_name.target = "_blank";
      td_node_name.appendChild(a_node_name);
      // hovertext showing alternative names
      td_node_name.title = names[taxid].length > 1 ?
        names[taxid].slice(1).join(", ") : names[taxid][0];
      tr.appendChild(td_node_name);

      for (let i = 0; i < column_samples.length; i++) {
        const samples = column_samples[i];
        const total_reads = column_totals[i];
        matches = 0;
        for (sample of samples) {
          const n = comparison_sample_counts?.[taxid]?.[sample];
          if (n) {
            matches += n;
          }
        }

        const td_val = e("td", cell_value(matches, total_reads, true));
        td_val.style.backgroundColor = comparison_color(matches/total_reads);
        tr.appendChild(td_val);
      }
      if (!added_divider) {
        add_divider(
          "Comparison clades.  Counts are of reads assigned anywhere in the "
            + "clade, and not just to human-infecting viruses.  Format "
            + "is 'relative_abundance (read count)'.");
      }
      added_divider = true;
      tbl.appendChild(tr);
    }
  }

  function add_divider(text) {
    tr_divider = e("tr");
    tr_divider.classList.add("divider");
    td_divider = e("td", text);
    td_divider.colSpan = column_samples.length + 2;
    tr_divider.appendChild(td_divider);
    tbl.appendChild(tr_divider);
  }

  render_comparison_nodes();

  loading.style.display = "none";
}

let active_followups = 0;

// When someone is typing quickly we don't want to search repeatedly.
function search_followup() {
  active_followups--;
  if (active_followups) return;

  redisplay();
}

function search(e) {
  check_input_errors();
  update_hash();
  active_followups++;
  if (e.type == "checkbox") {
    setTimeout(search_followup, 0);
  } else if (
      e.target.value.length > 3 ||
      e.target == na_paper_search ||
      e.target == min_reads_search) {
    setTimeout(search_followup, 100);
  } else {
    setTimeout(search_followup, 1000);
  }
}

na_paper_search.addEventListener("input", search);
min_reads_search.addEventListener("input", search);

taxonomic_search.addEventListener("input", search);
comparison_search.addEventListener("input", search);

comparison_viruses.addEventListener("input", search);
comparison_bacteria.addEventListener("input", search);
comparison_other.addEventListener("input", search);

country_search.addEventListener("input", search);
city_search.addEventListener("input", search);
na_sample_dna.addEventListener("input", search);
na_sample_rna.addEventListener("input", search);
na_sample_dna_rna.addEventListener("input", search);
enrichment_none.addEventListener("input", search);
enrichment_viral.addEventListener("input", search);
enrichment_panel.addEventListener("input", search);
date_begin_search.addEventListener("input", search);
date_end_search.addEventListener("input", search);

const searches_by_param_name = {
  "q": taxonomic_search,
  "cq": comparison_search,
  "country": country_search,
  "city": city_search,
  "date_begin": date_begin_search,
  "date_end": date_end_search,
  "mr": min_reads_search,
  "nap": na_paper_search,
};

const checkboxes_by_param_name = {
  "dna": na_sample_dna,
  "rna": na_sample_rna,
  "dna_rna": na_sample_dna_rna,
  "e_none": enrichment_none,
  "e_viral": enrichment_viral,
  "e_panel": enrichment_panel,
  "c_viruses": comparison_viruses,
  "c_bacteria": comparison_bacteria,
  "c_other": comparison_other,
}

if (window.location.hash) {
  const params = new URLSearchParams(window.location.hash.slice(1));
  for (param_name in searches_by_param_name) {
    if (params.has(param_name)) {
      searches_by_param_name[param_name].value = params.get(param_name);
    }
  }
  for (param_name in checkboxes_by_param_name) {
    checkboxes_by_param_name[param_name].checked =
      params.get(param_name) == "1";
  }
  for (const pinned_taxid of (params.get("pinned") || "").split(".")) {
    pinned_comparisons.add(Number(pinned_taxid));
  }
}

function update_hash() {
  const params = new URLSearchParams();
  for (param_name in searches_by_param_name) {
    if (searches_by_param_name[param_name].value) {
      params.set(param_name, searches_by_param_name[param_name].value);
    }
  }
  for (param_name in checkboxes_by_param_name) {
    if (checkboxes_by_param_name[param_name].checked) {
      params.set(param_name, "1");
    }
  }
  params.set("pinned", [...pinned_comparisons].join("."));
  window.location.hash = params.toString();
}

redisplay();

</script>
