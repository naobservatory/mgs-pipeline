<html>
  <div id=error_not_done class=hidden>
  Sample <span id=error_not_done_span></span> is not ready yet, sorry!
  </div>

  <input id=run_accession placeholder="run accession"></input>
  <button id=load_sample>Load</button>

  <p>

  <div id=sample_description></div>

  <p>

  <input id=taxonomic_search placeholder="taxonomic name" size=40></input>

<div id=reads></div>

<style>


  .read {
    background-color: #eee;
    border-radius: 0.5em;
    padding: 0.5em;
    margin: 1em;
  }

  .hidden {
    display: none;
  }

  #error_not_done {
    border: 1px solid red;
    border-radius: 0.5em;
    padding: 0.5em;
    margin: 0.5em;
  }
</style>

<script src="data.js"></script>
<script>

// imports:
//   names: taxid -> names
//   tree: taxid with children
//   sample_metadata: sample -> {country, date, location, reads}
//   papers: paper -> {link, na_type, [projects]}
//   bioprojects: project -> [samples]

function e(tag, innerText) {
  const el = document.createElement(tag);
  if (innerText) {
    el.innerText = innerText;
  }
  return el;
}

const K=35; // kraken default

function is_valid_run_accession(x) {
  return !!sample_metadata[x];
}

function include_all_children(target_taxids, node) {
  const taxid = node[0];
  target_taxids.add(taxid);
  for (let i = 1; i < node.length; i++) {
    include_all_children(target_taxids, node[i]);
  }
}

function add_taxonomic_children(target_taxids, node=tree) {
  const taxid = node[0];
  if (target_taxids.has(taxid)) {
    include_all_children(target_taxids, node);
    return;
  }
  for (let i = 1; i < node.length; i++) {
    add_taxonomic_children(target_taxids, node[i]);
  }
}

function search() {
  update_hash();

  const target_taxids = new Set();
  for (const taxid in names) {
    for (const name of names[taxid]) {
      if (name.toLowerCase().includes(taxonomic_search.value.toLowerCase())) {
        //console.log("Matched " + name + " adding " + taxid);
        target_taxids.add(Number(taxid));
      }
    }
  }

  //console.log(target_taxids);

  add_taxonomic_children(target_taxids);

  for (const read_div of reads.children) {
    // it's silly that js has Set but not Set.intersection
    let is_match = false;
    for (const read_taxid of read_div.taxids) {
      if (target_taxids.has(read_taxid)) {
        is_match = true;
        break;
      }
    }
    if (is_match) {
      read_div.classList.remove("hidden");
    } else {
      read_div.classList.add("hidden");
    }
  }
}

taxonomic_search.addEventListener("input", search);

function contextual_name(target_taxid, node=tree) {
  const taxid = node[0];
  if (taxid == target_taxid) {
    return names[taxid].join(", ");
  }
  for (let i = 1; i < node.length; i++) {
    const response = contextual_name(target_taxid, node[i]);
    if (response) {
      if (taxid == "1") return response;
      return names[taxid][0] + " > " + response;
    }
  }
  return null;
}

function human_readable(n) {
  function s(v, suffix) {
    let vStr = v.toPrecision(3);
    if (vStr.includes(".")) {
      vStr = v.toPrecision(2);
    }
    return vStr + suffix;
  }
  if (n < 1000) return n;
  n /= 1000;
  if (n < 1000) return s(n,'k');
  n /= 1000;
  if (n < 1000) return s(n,'M');
  n /= 1000;
  if (n < 1000) return s(n, 'B');
  n /= 1000;
  if (n < 1000) return s(n, 'T');
  n /= 1000;
  return s(n, 'Q');
}

function populate_sample_metadata() {
  while(sample_description.firstChild) {
    sample_description.removeChild(sample_description.firstChild);
  }
  const sample = run_accession.value;

  for (const paper_name in papers) {
    for (const bioproject of papers[paper_name].projects) {
      for (const potential_sample of bioprojects[bioproject]) {
        if (potential_sample == sample) {
          const a_paper = e("a", paper_name);
          a_paper.href = papers[paper_name].link;
          a_paper.target = "_blank";
          sample_description.appendChild(a_paper);
          sample_description.appendChild(e("br"));
        }
      }
    }
  }

  const m = sample_metadata[sample];
  sample_description.appendChild(e(
    "span", m.country || "Unknown country"));
  sample_description.appendChild(e("span", ", "));
  sample_description.appendChild(e(
    "span", m.location || "Unknown location"));
  if (m.fine_location) {
    sample_description.appendChild(e("span", ", "));
    sample_description.appendChild(e("span", m.fine_location));
  }
  sample_description.appendChild(e(
    "div", human_readable(m.reads) + " reads"));
  sample_description.appendChild(e(
    "div", m.date || "Unknown date"));
}

function load() {
  populate_sample_metadata();

  error_not_done.classList.add("hidden");
  fetch("hvreads/" + run_accession.value + ".hvreads.json").then(
    function(response) { return response.json(); }).then(
      loaded).catch(
        function () {
          error_not_done.classList.remove("hidden");
          error_not_done_span.innerText = run_accession.value;
        });
}

function loaded(seqs) {
  for (const seq_id in seqs) {
    const read_div = e("div");
    read_div.taxids = new Set();
    read_div.classList.add("read");
    read_div.appendChild(e("div", seq_id));

    const kraken_line = seqs[seq_id][0];
    read_div.appendChild(e("pre", kraken_line));

    for (let i = 1; i < seqs[seq_id].length; i++) {
      const seq = seqs[seq_id][i];
      read_div.appendChild(e("pre", seq));

      let seen_divider = false;
      let pos = 0;
      for (const kraken_match of kraken_line.split(" ")) {
        if (kraken_match == '|:|') {
          seen_divider = true;
          continue;
        }

        if (seqs[seq_id].length > 2) {
          // Non-collapsed case.
          // Read 1 is only pre-divider, read 2 is only post divider.
          if (i == 1 && seen_divider) break;
          if (i == 2 && !seen_divider) continue;
        }

        const [taxid, kmers_raw] = kraken_match.split(":");
        const kmers = Number(kmers_raw);
        if (taxid == '0' || taxid == 'A') {
          pos += kmers;
          continue;
        }

        let label = taxid;
        if (names[taxid]) {
          label = names[taxid][0];
          read_div.taxids.add(Number(taxid));
        }
        const max_label = K + kmers - 5;
        label += " ".repeat(max_label);
        label = label.slice(0, max_label);
        label = "| " + label + " |";
        const pre = e("pre", " ".repeat(pos));
        const a_taxid = e("a", label);
        a_taxid.href =
          "https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi" +
          "?lvl=0&id=" + taxid;
        if (names[taxid]) {
          a_taxid.title = contextual_name(taxid);
        }
        a_taxid.target = "_blank";
        pre.appendChild(a_taxid);
        read_div.appendChild(pre);
        pos += kmers;
      }
    }

    reads.appendChild(read_div);
  }
  search();
}

if (window.location.hash) {
  const params = new URLSearchParams(window.location.hash.slice(1));
  if (params.has("q")) {
    taxonomic_search.value = params.get("q");
  }
  if (params.has("run")) {
    run_accession.value = params.get("run");
    validate_and_load();
  }
}

function update_hash() {
  const params = new URLSearchParams();
  if (taxonomic_search.value) {
    params.set("q", taxonomic_search.value);
  }
  if (run_accession.value) {
    params.set("run", run_accession.value);
  }
  window.location.hash = params.toString();
}

function validate_and_load() {
  update_hash();
  if (is_valid_run_accession(run_accession.value)) {
    run_accession.style.backgroundColor = "";
    load();
  } else {
    run_accession.style.backgroundColor = "pink";
  }
}

load_sample.onclick = validate_and_load;

</script>
</html>
